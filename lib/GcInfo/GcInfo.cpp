//===-------- include/gcinfo/gcinfo.cpp -------------------------*- C++ -*-===//
//
// LLILC
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license.
// See LICENSE file in the project root for full license information.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// \brief Implements the generation of CLR GCTables in LLILC
///
//===----------------------------------------------------------------------===//

#include "earlyincludes.h"
#include "GcInfo.h"
#include "Target.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/SmallBitVector.h"
#include "llvm/Object/StackMapParser.h"
#include <sstream>

using namespace llvm;

GCInfo::GCInfo(LLILCJitContext *JitCtx, uint8_t *StackMapData,
               uint8_t *CodeBlkStart, GcInfoAllocator *Allocator)
    : JitContext(JitCtx), LLVMStackMapData(StackMapData),
      CodeBlockStart(CodeBlkStart),
      Encoder(JitContext->JitInfo, JitContext->MethodInfo, Allocator) {
#if !defined(NDEBUG)
  this->EmitLogs = JitContext->Options->LogGcInfo;
#endif // !NDEBUG
#if defined(PARTIALLY_INTERRUPTIBLE_GC_SUPPORTED)
  this->CallSites = nullptr;
  this->CallSiteSizes = nullptr;
#endif // defined(PARTIALLY_INTERRUPTIBLE_GC_SUPPORTED)
}

void GCInfo::encodeHeader() {
#if !defined(NDEBUG)
  if (EmitLogs) {
    dbgs() << "GcTable for Function: " << JitContext->MethodName << "\n"
           << "  Size: " << JitContext->HotCodeSize << "\n";
  }
#endif // !NDEBUG

  // TODO: Set Code Length accurately.
  // https://github.com/dotnet/llilc/issues/679
  // JitContext->HotCodeSize is the size of the allocated code block.
  // It is not the actual length of the current function's code.
  Encoder.SetCodeLength(JitContext->HotCodeSize);

#if defined(FIXED_STACK_PARAMETER_SCRATCH_AREA)
  // TODO: Set size of outgoing/scratch area accurately
  // https://github.com/dotnet/llilc/issues/681
  Encoder.SetSizeOfStackOutgoingAndScratchArea(0);
#endif // defined(FIXED_STACK_PARAMETER_SCRATCH_AREA)
}

void GCInfo::encodeLiveness() {
  if (LLVMStackMapData == nullptr) {
    return;
  }

  ArrayRef<uint8_t> StackMapContentsArray(LLVMStackMapData,
                                          JitContext->StackMapSize);

#if defined(BIGENDIAN)
  typedef StackMapV1Parser<support::big> StackMapParserType;
#else
  typedef StackMapV1Parser<support::little> StackMapParserType;
#endif
  StackMapParserType StackMapParser(StackMapContentsArray);

  assert(StackMapParser.getNumFunctions() == 1 &&
         "Expect only one function with GcInfo in the module");

  // The InstructionOffsets for Call-sites are with respect to:
  // (1) FunctionEntry in LLVM's StackMap
  // (2) CodeBlockStart in CoreCLR's GcTable
  //
  // There is typically a difference between the two even in the JIT case
  // (where we emit one function per module) because of some additional
  // code like the gc.statepoint_poll() method.

  uint8_t *FunctionEntry =
      (uint8_t *)StackMapParser.getFunction(0).getFunctionAddress();

  size_t OffsetCorrection = FunctionEntry - CodeBlockStart;

// Loop over LLVM StackMap records to:
// 1) Note CallSites (safepoints)
// 2) Assign Slot-IDs to each unique gc-pointer location (slot)
// 3) Record liveness (birth/death) of slots per call-site.

#if defined(PARTIALLY_INTERRUPTIBLE_GC_SUPPORTED)
  NumCallSites = StackMapParser.getNumRecords();
  CallSites = new unsigned[NumCallSites];
  CallSiteSizes = new BYTE[NumCallSites];
#endif // defined(PARTIALLY_INTERRUPTIBLE_GC_SUPPORTED)

  // TODO: Determine call-site-size accurately
  // https://github.com/Microsoft/llvm/issues/56
  // Call-site size is not available in LLVM's StackMap v1, so just make up
  // a value for now. The Call-instruction generated by LLILC on X86/X64
  // is typically Call [rax], which has a two-byte encoding.
  //
  // Any size > 0 can be reported as CallSizeSize, see explanation below.
  //
  // CoreCLR's API expects that we report:
  // (a) the offset at the beginning of the Call instruction, and
  // (b) size of the call instruction.
  //
  // LLVM's stackMap currently only reports:
  // (c) the offset at the safepoint after the call instruction (= a+b)
  //
  // When not in a fully-intrruptible block, CoreCLR only
  // uses the value of (a+b) to determine the end of the call
  // instruction. Therefore, we simply report a = c and b = 0 for now.
  //
  // Once call-size size is available in LLVM StackMap v2, we can remove this
  // implementation specific workaround.

  const uint8_t CallSiteSize = 2;

  DenseMap<int32_t, GcSlotId> SlotMap;
  size_t NumSlots = 0;

  // LLVM StackMap records all live-pointers per Safepoint, whereas
  // CoreCLR's GCTables record pointer birth/deaths per Safepoint.
  // So, we do the translation using old/new live-pointer-sets
  // using bit-sets for recording the liveness -- one bit per slot.

  size_t LiveBitSetSize = 25;
  SmallBitVector OldLiveSet(LiveBitSetSize);
  SmallBitVector NewLiveSet(LiveBitSetSize);

  // TODO: Identify Object and Managed pointers differently
  // https://github.com/dotnet/llilc/issues/28
  // We currently conservatively describe all slots as containing
  // interior pointers
  const GcSlotFlags SlotFlags = (GcSlotFlags)GC_SLOT_INTERIOR;

#if !defined(NDEBUG)
  if (EmitLogs) {
    dbgs() << "  FunctionEntry: " << FunctionEntry << "\n"
           << "  #Safepoints: " << StackMapParser.getNumRecords() << "\n";
  }

  std::ostringstream SlotStream;
  std::ostringstream LiveStream;
#endif // !NDEBUG

  size_t RecordIndex = 0;
  for (const auto &R : StackMapParser.records()) {

    // InstructionOffset:
    // + OffsetCorrection: to account for any bytes before the start
    //                     of the function.
    // - CallSiteSize: to report the start of the Instruction
    //
    // LLVM's Safepoint reports the offset at the end of the Call
    // instruction, whereas the CoreCLR API expects that we report
    // the start of the Call instruction.

    unsigned InstructionOffset =
        R.getInstructionOffset() + OffsetCorrection - CallSiteSize;

#if defined(PARTIALLY_INTERRUPTIBLE_GC_SUPPORTED)
    CallSites[RecordIndex] = InstructionOffset;
    CallSiteSizes[RecordIndex] = CallSiteSize;
#endif // defined(PARTIALLY_INTERRUPTIBLE_GC_SUPPORTED)

#if !defined(NDEBUG)
    if (EmitLogs) {
      LiveStream << "    " << RecordIndex << ": @" << InstructionOffset;
    }
#endif // !NDEBUG

    // We don't generate GC_CALLER_SP_REL locatons, just
    // using this as a default value other than SP/FP REL.
    GcStackSlotBase SpBase = GC_CALLER_SP_REL;

    for (const auto &Loc : R.locations()) {

      switch (Loc.getKind()) {
      case StackMapParserType::LocationKind::Constant:
      case StackMapParserType::LocationKind::ConstantIndex:
        continue;

      case StackMapParserType::LocationKind::Register:
        // TODO: Report Live - GC values in Registers
        // https://github.com/dotnet/llilc/issues/474
        // Live gc-pointers are currently spilled to the stack at Safepoints.
        assert(false && "GC-Pointer Live in Register");
        break;

      case StackMapParserType::LocationKind::Direct: {
        uint16_t DwReg = Loc.getDwarfRegNum();
        switch (DwReg) {
        case DW_FRAME_POINTER:
          assert(SpBase != GC_SP_REL && "Mixed SP/FP based Locations");
          SpBase = GC_FRAMEREG_REL;
          break;
        case DW_STACK_POINTER:
          assert(SpBase != GC_FRAMEREG_REL && "Mixed SP/FP based Locations");
          SpBase = GC_SP_REL;
          break;
        default:
          assert(false && "Unexpected stack base-pointer");
        }

        GcSlotId SlotID;
        int32_t Offset = Loc.getOffset();
        DenseMap<int32_t, GcSlotId>::const_iterator ExistingSlot =
            SlotMap.find(Offset);
        if (ExistingSlot == SlotMap.end()) {
          SlotID = Encoder.GetStackSlotId(Offset, SlotFlags, SpBase);
          SlotMap[Offset] = SlotID;

          assert(SlotID == NumSlots && "SlotIDs dis-contiguous");
          NumSlots++;

          if (NumSlots > LiveBitSetSize) {
            LiveBitSetSize += LiveBitSetSize;

            assert(LiveBitSetSize > OldLiveSet.size() &&
                   "Overflow -- Too many live pointers");

            OldLiveSet.resize(LiveBitSetSize);
            NewLiveSet.resize(LiveBitSetSize);
          }

#if !defined(NDEBUG)
          if (EmitLogs) {
            SlotStream << "    [" << SlotID
                       << "]: " << ((SpBase == GC_SP_REL) ? "sp+" : "fp+")
                       << Offset << "\n";
          }
#endif // !NDEBUG
        } else {
          SlotID = ExistingSlot->second;
        }

        NewLiveSet[SlotID] = true;
        break;
      }

      default:
        assert(false && "Unexpected Location Type");
        break;
      }
    }

    for (GcSlotId SlotID = 0; SlotID < NumSlots; SlotID++) {
      if (!OldLiveSet[SlotID] && NewLiveSet[SlotID]) {
#if !defined(NDEBUG)
        if (EmitLogs) {
          LiveStream << "  +" << SlotID;
        }
#endif // !NDEBUG
        Encoder.SetSlotState(InstructionOffset, SlotID, GC_SLOT_LIVE);
      } else if (OldLiveSet[SlotID] && !NewLiveSet[SlotID]) {
#if !defined(NDEBUG)
        if (EmitLogs) {
          LiveStream << "  -" << SlotID;
        }
#endif // !NDEBUG
        Encoder.SetSlotState(InstructionOffset, SlotID, GC_SLOT_DEAD);
      }

      OldLiveSet[SlotID] = NewLiveSet[SlotID];
      NewLiveSet[SlotID] = false;
    }

    RecordIndex++;

#if !defined(NDEBUG)
    if (EmitLogs) {
      LiveStream << "\n";
    }
#endif // !NDEBUG
  }

#if !defined(NDEBUG)
  if (EmitLogs) {
    dbgs() << "  Slots:\n" << SlotStream.str();
    dbgs() << "  Safepoints:\n" << LiveStream.str() << "\n";
  }
#endif // !NDEBUG

  // Finalize Slot IDs to enable compact representation
  Encoder.FinalizeSlotIds();

#if defined(PARTIALLY_INTERRUPTIBLE_GC_SUPPORTED)
  // Encode Call-sites
  Encoder.DefineCallSites(CallSites, CallSiteSizes, NumCallSites);
#endif // defined(PARTIALLY_INTERRUPTIBLE_GC_SUPPORTED)
}

void GCInfo::emitEncoding() {
  Encoder.Build();
  Encoder.Emit();
}

GCInfo::~GCInfo() {
#if defined(PARTIALLY_INTERRUPTIBLE_GC_SUPPORTED)
  delete CallSites;
  delete CallSiteSizes;
#endif // defined(PARTIALLY_INTERRUPTIBLE_GC_SUPPORTED)
}

void GCInfo::emitGCInfo() {
  encodeHeader();
  encodeLiveness();
  emitEncoding();
}
